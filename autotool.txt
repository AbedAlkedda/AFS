Proof { word = "101111", exp = ((1 0 ((1 1)^* + 1))^*), reason = Star_Positive
  {
    left = Proof { word = "101111", exp = (1 0 ((1 1)^* + 1)), reason = Dot {
        left  = Proof { word = "10",exp = (10),reason = Dot {
            left  = Proof { word = "1", exp = (1), reason = Letter },
            right = Proof { word = "0", exp = (0), reason = Letter }
          }
        
        },
    right = Proof { word = "1111", exp = (((1 1)^* + 1)), reason = Union_Left (
          Proof {
              word = "1111", exp = ((1 1)^*), reason = Star_Positive {
                left  = Proof { word = "11", exp = ((1 1)) , reason = Dot {
                  left  = Proof { word = "1", exp = (1), reason = Letter },
                  right = Proof { word = "1", exp = (1), reason = Letter }
                }},
                right = Proof { word = "11", exp = ((1 1)^*), reason = Star_Positive {
                    left  = Proof { word = "11", exp =((1 1)), reason = Dot {
                        left  = Proof { word = "1", exp = (1), reason = Letter },
                        right = Proof { word = "1", exp = (1), reason = Letter }
                      }
                    },
                    right = Proof { word = "", exp = ((1 1)^*), reason = Star_Zero }
                  }
                }
              }
            }
          )
        }
      }
    },
    right = Proof { word = "", exp = ((1 0 ((1 1)^* + 1))^*), reason = Star_Zero }
  }
}







(
  Proof {
    word = "aaaaaa",
    exp = (((a + b)^* a (a a))^*),
    reason = Star_Positive {
      left  = Proof {word = "aaa", exp = (((a + b)^* a (a a))), reason = Dot {
        left  = Proof {word = "a", exp = ((a + b)^* a), reason = Dot {
          left = Proof {word = "", exp = ((a+b)^*), reason = Star_Zero },
          right = Proof {word = "a", exp = (a), reason = Letter}
        } },
        right = Proof {word = "aa", exp = ((a a)), reason = Dot {
          left =  Proof {word = "a" , exp = (a) , reason = Letter},
          right = Proof {word = "a" , exp = (a), reason = Letter}
        }
      }}},

      right = Proof { word = "aaa", exp = (((a + b)^* a (a a))^*), reason = Star_Positive {
        left = Proof { word = "aaa", exp = (((a + b)^* a (a a))), reason = Dot {
          left  = Proof {word = "a", exp = ( (a + b)^* a ), reason = Dot {
            left  = Proof {word = "", exp = ((a + b)^* ), reason = Star_Zero },
            right = Proof {word = "a" , exp = (a), reason = Letter}
          } },
          right = Proof {word = "aa",exp = ((a a)), reason = Dot {
            left = Proof {word = "a", exp = (a), reason = Letter},
            right = Proof {word = "a" , exp = (a), reason = Letter}
          }}
        } } ,
        right = Proof { word= "", exp = (((a + b)^* a (a a))^*), reason = Star_Zero }
      } }
    }
  }
, Proof {
  word = "aaaaaa",
  exp = (((a + b)^* a (a a))^*),
  reason = Star_Positive {
      left = Proof {word = "aaaaaa", exp = (((a + b)^* a (a a))), reason = Dot {
        left  = Proof {word = "aaaa", exp = ((a + b)^* a), reason = Dot {



          left  = Proof {word = "aaa", exp = ((a + b)^* ), reason = Star_Positive {
            left = Proof {word = "a", exp = ((a + b)), reason = Union_Left (
              Proof {word = "a", exp = (a), reason = Letter}
            )},



            right = Proof{word = "aa", exp = ((a + b)^*), reason = Star_Positive {
              left = Proof {word = "a", exp = ((a + b)), reason = Union_Left (
              Proof {word = "a", exp = (a), reason = Letter}
            )},
              right = Proof {word = "a", exp = ( (a + b)^* ), reason = Star_Positive {
                left = Proof {word = "a", exp = ( (a + b) ), reason = Union_Left (
                  Proof {word = "a", exp = (a), reason = Letter}
                )},
                right = Proof {word = "", exp = ((a + b) ^* ), reason = Star_Zero}
              }}
            } }
          }}, 
          right = Proof {word  = "a", exp = (a), reason = Letter }
        } },
        right = Proof {word = "aa" , exp = ((a a)), reason = Dot {
          left = Proof {word = "a", exp = (a), reason = Letter },
          right = Proof {word = "a", exp = (a), reason = Letter}
        }}
      }},
      right = Proof {word = "", exp = (((a + b)^* a (a a))^*), reason = Star_Zero}
    }
  } 
)


Gegeben ist der regul채re Ausdruck
    (a + b)^* b (a + b)^2
Gesucht ist ein dazu 채quivalenter endlicher Automat
mit folgenden Eigenschaften
Sane
    Deterministic
    Complete
    Alphabet (mkSet 
      "ab")

NFA 
  { alphabet = mkSet "ab"
  , states = mkSet [ 1, 2, 3, 4, 5, 6, 7, 8 ]
  , starts = mkSet [ 1 ]
  , finals = mkSet [ 4, 6, 7, 8 ]
  , trans = collect 
    [ 
      ( 1, 'a', 1 ), ( 1 ,'b', 2 ),
      ( 2, 'a', 5 ), ( 2, 'b', 3 ),
      ( 3, 'a', 6 ), ( 3, 'b', 4 ),
      ( 4, 'a', 6 ), ( 4, 'b', 4 ),
      ( 5, 'a', 8 ), ( 5, 'b', 7 ),
      ( 6, 'a', 8 ), ( 6, 'b', 7 ),
      ( 7, 'a', 5 ), ( 7, 'b', 3 ),
      ( 8, 'a', 1 ), ( 8, 'b', 2 )    
    ]
  }


Gegeben ist der regul채re Ausdruck
    (b b)^* (b a)^*
Gesucht ist ein dazu 채quivalenter endlicher Automat
mit folgenden Eigenschaften
Sane
    Deterministic
    Complete
    Alphabet (mkSet 
      "ab")


NFA
  { alphabet = mkSet "ab"
  , states = mkSet [ 1, 2, 3, 4, 5, 6 ]
  , starts = mkSet [ 1 ]
  , finals = mkSet [ 3, 4 ]
  , trans = collect 
    [
      ( 1, 'a', 6 ), ( 1, 'b', 2 ),
      ( 2, 'a', 4 ), ( 2, 'b', 3 ),
      ( 3, 'a', 6 ), ( 3, 'b', 2 ),
      ( 4, 'a', 6 ), ( 4, 'b', 5 ),
      ( 5, 'a', 4 ), ( 5, 'b', 6 ),
      ( 6, 'a', 6 ), ( 6, 'b', 6 )
    ] 
  }


# NFA zu DFA
NFA 
  { alphabet = mkSet "ab"
  , states = mkSet [ 1, 2, 3,4,5,0,13,12,25,45,134,34,123,125,245,345 ]
  , starts = mkSet [ 1 ]
  , finals = mkSet [ 5,25,125,45,245,345 ]
  , trans = collect 
      [ 
        ( 1, 'a', 2)
      , ( 1, 'b', 0)

      , ( 2, 'a', 5)
      , ( 2, 'b', 4)

      , ( 3, 'a', 1)
      , ( 3, 'b', 3)

      , ( 4, 'a', 3)
      , ( 4, 'b', 4)

      , ( 5, 'a', 4)
      , ( 5, 'b', 13)

      , ( 0, 'a', 0)
      , ( 0, 'b', 0)

      , ( 13, 'a', 12)
      , ( 13, 'b', 3)

      , ( 12, 'a', 25)
      , ( 12, 'b', 4)

      , ( 25, 'a', 45)
      , ( 25, 'b', 134)

      , ( 45, 'a', 34)
      , ( 45, 'b', 134)

      , ( 134, 'a', 123)
      , ( 134, 'b', 34)

      , ( 34, 'a', 13)
      , ( 34, 'b', 34)

      , ( 123, 'a', 125)
      , ( 123, 'b', 34)

      , ( 125, 'a', 245)
      , ( 125, 'b', 134)

      , ( 245, 'a', 345)
      , ( 245, 'b', 134)

      , ( 345, 'a', 134)
      , ( 345, 'b', 134)
      ]
  }
